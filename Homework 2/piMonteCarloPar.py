"""
    Parallel Computing
    2022/2023 1st semester
    Exercise Sheet #1 21-09-2022
    ============================================================

    This code is to be run on four cores or threads.
"""

from random import randint, random
from mpi4py import MPI
import math
import matplotlib.pyplot as plt
import sys
import time

"""
    Chapter 1 - Main Procedure
    ------------------------------------------------------------
"""
# Start the time counter
timeInit = time.time()
# This code is necessarity to run the livrary
# Init MPI ENV
comm = MPI.COMM_WORLD
# Each thread gets its rank
rank = comm.Get_rank()
# Total number of threads
threads =  MPI.COMM_WORLD.Get_size()

# The n is obtained from the terminal 
# N is the number of total random points
n = int(float(sys.argv[1]))

# Each thread will only run a fraction ot the total points
nThread = n//threads

# Number of points inside de circle
counter = 0

# Just var to check the number of point generated by each thread
nCheck = 0

# Generate two numbers for n times and check if they are inside the circle
for i in range(nThread):
    x = random()*2 - 1
    y = random()*2 - 1

    nCheck += 1

    r = math.sqrt(x**2 + y**2)

    if r < 1:
        counter += 1


# The value of pi calculated
result = 4*counter/nThread


"""
    Chapter 2 - MPI & Results
    ------------------------------------------------------------
"""
# For the rank 0 thread
if rank == 0:
    print (f'you entered {n}')


    print ('Number of processes:', threads)
    # Print the result on thread 0
    print('On process', rank, 'result is', result, 'for', nCheck, 'points')

    # And for each thread
    for thread in range(1, threads):
        # Read the corresponding dictionary
        resultThread = comm.recv(source = thread)
        print('On process', thread, 'result is', resultThread[0], 'for', resultThread[1], 'points')
        # Add the dictionary from each thread, to the general dictionary

        counter += resultThread[2]
        nCheck += resultThread[1]
        result += resultThread[0]

    
        
    timeEnd = time.time()
    duration = timeEnd - timeInit

    print ('Final result:         ', result/threads, "for", nCheck, "points. \n This program took:", duration, " segundos.")
    ratio = counter/n
    Zc = 1
    deltaPi = 4*Zc*math.sqrt(ratio*(1 - ratio)/n)

    print(f'Error on the pi calculated: {deltaPi}.')



else:
    # Each thread sends its dictionary to rank zero thread
    comm.send([result, nCheck, counter], dest=0)
    

"""
    Chapter 3 - The Verdict
    ------------------------------------------------------------
    This simulation was run with the mpi API. I measured the run
    time three times:
        - 326 seg
        - 310 seg
        - 318 seg
    
"""